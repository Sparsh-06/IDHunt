import express from "express";
import responseRoutes from "./routes/responses.js";
import cors from "cors";
import dotenv from "dotenv";
import express from "express";
import OpenAI from "openai";
import dotenv from "dotenv";
import { v4 as uuidv4 } from "uuid";

dotenv.config();

import { MongoClient } from "mongodb";


dotenv.config();

// Create a MongoClient with a MongoClientOptions object to set the Stable API version

const app = express();

// Middleware to parse JSON bodies
app.use(express.json());
app.use(cors(
  {
    origin: '*',
    methods: 'GET,POST',
    credentials: true
  }
));

// Use the app

// Start the server
const PORT = process.env.PORT || 3200;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

app.get("/hehe", (req, res) => {
  res.send("Hello to the Responses API");
});

const client = new MongoClient(process.env.MongoDB_URI);

async function createMessageResponse(userId, response, isPrivate, devName) {
  try {
    // Connect to the MongoDB client
    await client.connect();

    // Insert the message, userId, and response into the 'responses' collection
    const result = await client.db("GetStack").collection("ideas").insertOne({
      userId: userId,
      isPrivate: isPrivate,
      response: response.content,
      devName: devName,
      createdAt: new Date(),
    });
    console.log(`Response saved with id: ${result.insertedId}`);
  } finally {
    await client.close(); // Close the client after insertion
  }
}

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  projectId: process.env.OPENAI_PROJECT_ID,
});

// Define the prompt
const prompt = `
You are an expert software developer, built multi-billionaire Softwares, has participated many hackathons and won all of them and built amazing unique projects which has been awarded multiple times and you will help me generate a detailed new project hackathon idea details with the following details:
1. Title: Some catchy name suggestions for the project idea.
2. Problem Statement: Problem statement that the project idea will solve.
3. Objective: Objective of the project.
2. Tech Stack: List all the technologies (frontend, backend, database, 3rd-party services, Artificial Intelligence techs, accroding to you and the idea, etc.), with each tech having a name and answer of why is this tech good for this project? briefly.
3. Pros: List 5 detailed benefits of using the suggested tech stack.
4. Cons: List 3 detailed downsides of the suggested tech stack.
5. Marketing: List 2 marketing strategies to promote the project.
6. User Flow : Detailed user flow of the software.
7. Profitablity: an esimtation of the profitablity of the project according to the current market trends and subscription model for this specific project.
8. USP: Unique Selling Point of the project.
9. Competitors (if any): List of competitors.
Keep the response very detailed and informative.`;
const getResponse = async (message, userId) => {
  try {
    await client.connect();
    const db = client.db("GetStack");
    const collection = db.collection("userIdeaCounts");

    // Check the number of ideas generated by the user
    const userIdeaCount = await collection.findOne({ userId });

    if (userIdeaCount && userIdeaCount.count >= 2) {
      throw new Error("User has exceeded the limit of generating ideas.");
    }

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini-2024-07-18",
      messages: [
        { role: "system", content: prompt },
        {
          role: "user",
          content: message,
        },
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "project_idea_details",
          schema: {
            type: "object",
            properties: {
              title: {
                type: "array",
                description:
                  "Some catchy name suggestions for the project idea.",
                items: {
                  type: "string",
                },
              },
              desc: {
                type: "string",
                description: "Brief description of the project.",
              },
              tech_stack: {
                type: "array",
                description: "List all the technologies for the project.",
                items: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the technology.",
                    },
                    why_good: {
                      type: "string",
                      description:
                        "Reason why this tech is good for the project.",
                    },
                  },
                  required: ["name", "why_good"],
                  additionalProperties: false,
                },
              },
              pros: {
                type: "array",
                description:
                  "List 5 detailed benefits of using the suggested tech stack.",
                items: {
                  type: "string",
                },
              },
              cons: {
                type: "array",
                description:
                  "List 3 detailed downsides of the suggested tech stack.",
                items: {
                  type: "string",
                },
              },
              marketing: {
                type: "array",
                description:
                  "List 2 marketing strategies to promote the project.",
                items: {
                  type: "string",
                },
              },
              user_flow: {
                type: "array",
                description: "Detailed user flow of the software.",
                items: {
                  type: "string",
                },
              },
              profitability: {
                type: "string",
                description: "Estimation of the profitability of the project.",
              },
              usp: {
                type: "string",
                description: "Unique Selling Point of the project.",
              },
              competitors: {
                type: "array",
                description: "List of competitors.",
                items: {
                  type: "string",
                },
              },
            },
            required: [
              "title",
              "tech_stack",
              "pros",
              "cons",
              "marketing",
              "user_flow",
              "profitability",
              "usp",
              "competitors",
              "desc",
            ],
            additionalProperties: false,
          },
          strict: true,
        },
      },
    });

    // Ensure the response is valid JSON
    const responseText = response.choices[0].message;
    console.log(responseText);
    console.log(typeof responseText);

    // Increment the user's idea count
    if (userIdeaCount) {
      await collection.updateOne({ userId }, { $inc: { count: 1 } });
    } else {
      await collection.insertOne({ userId, count: 1 });
    }

    return responseText; // Parse as JSON
  } catch (error) {
    console.error("Error in GPT response:", error);
    throw new Error("Failed to get response from OpenAI.");
  } finally {
    await client.close();
  }
};

const setIdeaValidationDB = async (
  devName,
  ideaUrl,
  ideaTitle,
  ideaTag,
  ideaComp,
  isOpenSource,
  ideaDescription,
  userId,
  targetAudience,
  problemSolved,
  launchDate,
  techStack,
  teamSize,
  repoLink,
  budget,
  selectedTechnologies
) => {
  try {
    await client.connect();
    const db = client.db("GetStack");
    const collection = db.collection("ideaValidations");
    const result = await collection.insertOne({
      projectID: uuidv4(),
      userId: userId,
      devName: devName,
      ideaUrl: ideaUrl,
      ideaTitle: ideaTitle,
      ideaComp: ideaComp,
      upvotes: 0,
      downvotes: 0,
      ideaTag: ideaTag,
      isOpenSource: isOpenSource,
      ideaDescription: ideaDescription,
      targetAudience: targetAudience,
      problemSolved: problemSolved,
      launchDate: launchDate,
      techStack: techStack,
      teamSize: teamSize,
      repoLink: repoLink,
      budget: budget,
      selectedTechnologies: selectedTechnologies,
      createdAt: new Date(),
    });
    console.log(`Idea validation saved with id: ${result.insertedId}`);
  } catch (error) {
    console.error("Error creating collection:", error);
  } finally {
    await client.close();
  }
};

const updateVoteCount = async (ideaID, voteType) => {
  try {
    await client.connect();
    const db = client.db("GetStack");
    const collection = db.collection("ideaValidations");

    // Update the upvotes or downvotes based on the voteType
    const updateField =
      voteType === "upvote"
        ? { $inc: { upvotes: 1 } }
        : { $inc: { downvotes: 1 } };
    const result = await collection.updateOne(
      { projectID: ideaID },
      updateField
    );

    if (result.modifiedCount === 0) {
      throw new Error("Failed to update vote count");
    }
  } catch (error) {
    console.error("Error updating vote count:", error);
    throw error;
  } finally {
    await client.close();
  }
};

const recordUserVote = async (userId, ideaID, voteType) => {
  try {
    await client.connect();
    const db = client.db("GetStack");
    const collection = db.collection("userVotes");

    // Check if the user has already voted on this idea
    const existingVote = await collection.findOne({ userId, ideaID });
    if (existingVote) {
      throw new Error("User has already voted on this idea.");
    }

    // Record the new vote
    await collection.insertOne({ userId, ideaID, voteType });
  } catch (error) {
    console.error("Error recording user vote:", error);
    throw error;
  } finally {
    await client.close();
  }
};

// Define routes for the users

app.post("/api/sendMessage", async (req, res) => {
  try {
    const { message, userId, isPrivate, devName } = req.body;
    if (!message) {
      return res.status(400).json({ error: "Message content is required." });
    }
    const response = await getResponse(message, userId);
    await createMessageResponse(userId, response, isPrivate, devName);
    res.status(200).json({ data: response });
  } catch (error) {
    console.error(error);
    if (error.message === "User has exceeded the limit of generating ideas.") {
      return res
        .status(400)
        .json({ error: "You have exceeded the limit of generating ideas." });
    }
    res.status(500).json({ error: "Failed to process the message." });
  }
});

app.post("/api/submit-idea", async (req, res) => {
  const {
    formData,
    userId,
  } = await req.body;

  console.log(req.body);
  console.log(formData);


  await setIdeaValidationDB(
    formData.devName,
    formData.ideaUrl,
    formData.ideaTitle,
    formData.ideaTag,
    formData.ideaComp,
    formData.isOpenSource,
    formData.ideaDescription,
    userId,
    formData.targetAudience,
    formData.problemSolved,
    formData.launchDate,
    formData.techStack,
    formData.teamSize,
    formData.repoLink,
    formData.budget,
    formData.selectedTechnologies
  ).then(() => {
    res.status(200).json({ message: "Idea submitted successfully" });
  });

  // saving the data to the database
  // Save the idea to the database in another collection
  // (similar to the messages collection) for later review
  // Connect to the MongoDB client

  // Simulate a successful response
});

app.get("/api/ideas", async (req, res) => {
  try {
    await client.connect();
    const userId = req.query.userId;
    const query = userId ? { userId: userId } : {};
    const messages = await client
      .db("GetStack")
      .collection("ideas")
      .find(query)
      .toArray();
    res.status(200).json({ data: messages });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Failed to get messages." });
  } finally {
    await client.close();
  }
});
app.get("/api/getValidationIdeas", async (req, res) => {
  try {
    await client.connect();
    const messages = await client
      .db("GetStack")
      .collection("ideaValidations")
      .find()
      .toArray();
    res.status(200).json({ data: messages });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Failed to get messages." });
  } finally {
    await client.close();
  }
});

app.get("/api/getValidationIdeas/:id", async (req, res) => {
  try {
    await client.connect();
    const messages = await client
      .db("GetStack")
      .collection("ideaValidations")
      .findOne({ projectID: req.params.id });
    res.status(200).json({ data: [messages] });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Failed to get messages." });
  } finally {
    await client.close();
  }
});

app.post("/api/upvoteIdea/:ideaID", async (req, res) => {
  try {
    const { ideaID } = req.params;
    const { userId, feedback } = req.body; // Assuming userId and feedback are included in the request body

    // Here, you can implement logic to save the feedback if necessary
    await recordUserVote(userId, ideaID, "upvote");
    await updateVoteCount(ideaID, "upvote");
    res.status(200).json({ message: "Upvote recorded successfully" });
  } catch (error) {
    console.error(error);
    if (error.message === "User has already voted on this idea.") {
      return res
        .status(400)
        .json({ error: "You have already voted on this idea." });
    }
    res.status(500).json({ error: "Failed to upvote idea." });
  }
});

// Define the route for downvoting an idea
app.post("/api/downvoteIdea/:ideaID", async (req, res) => {
  try {
    const { ideaID } = req.params;
    const { userId, feedback } = req.body; // Assuming userId and feedback are included in the request body

    // Here, you can implement logic to save the feedback if necessary
    await recordUserVote(userId, ideaID, "downvote");
    await updateVoteCount(ideaID, "downvote");
    res.status(200).json({ message: "Downvote recorded successfully" });
  } catch (error) {
    console.error(error);
    if (error.message === "User has already voted on this idea.") {
      return res
        .status(400)
        .json({ error: "You have already voted on this idea." });
    }
    res.status(500).json({ error: "Failed to downvote idea." });
  }
});

app.get("/api/all-ideas", async (req, res) => {
  try {
    await client.connect();
    const messages = await client
      .db("GetStack")
      .collection("ideas")
      .find({ isPrivate: false })
      .toArray();
    res.status(200).json({ data: messages });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Failed to get messages." });
  } finally {
    await client.close();
  }
});

const userIDValidation = async (userId, updatedFields) => {
  try {
    const db = client.db("GetStack");
    const collection = db.collection("userProfiles");

    // Check if the user already exists
    const existingUser = await collection.findOne({ userId });
    if (existingUser) {
      // Update user profile if they exist
      await collection.updateOne(
        { userId },
        {
          $set: updatedFields,
        }
      );
      return true; // Indicate that the user profile was updated
    }
    return false; // Indicate that the user profile does not exist
  } catch (error) {
    console.error("Error validating user ID:", error);
    throw error;
  }
};

app.post("/api/profile", async (req, res) => {
  const { userId, name, username, headline, company, role, about } = req.body;

  try {
    await client.connect();
    const db = client.db("GetStack");
    const collection = db.collection("userProfiles");

    // Check if the user exists and update if necessary
    const userExists = await userIDValidation(userId, {
      name,
      username,
      headline,
      company,
      role,
      about,
    });

    if (userExists) {
      res.status(200).json({ message: "Profile updated successfully" });
    } else {
      // Insert a new profile if the user does not exist
      const result = await collection.insertOne({
        userId,
        name,
        username,
        headline,
        company,
        role,
        about,
      });
      res
        .status(201)
        .json({
          message: "Profile created successfully",
          id: result.insertedId,
        });
    }
  } catch (error) {
    console.error("Error creating or updating profile:", error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    await client.close();
  }
});

app.get("/api/ViewProfile", async (req, res) => {
  try {
    await client.connect();
    const userId = req.query.userId;
    const query = userId ? { userId: userId } : {};
    const profiles = await client
      .db("GetStack")
      .collection("userProfiles")
      .find(query)
      .toArray();
    res.status(200).json({ data: profiles });
  } catch (error) {
    console.error("Error getting profiles:", error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    await client.close();
  }
});

